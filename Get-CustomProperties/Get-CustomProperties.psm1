<#
	Generated by: Michael Rhyndress
	Generated on: 8/7/2017
#>

Import-Module (`
    Get-Item (`
        [System.IO.Path]::GetFullPath((`
            Join-Path $PSScriptRoot '../Test-IfFileLocked')`
        )`
    )`
)
Function Get-CustomProperties {

<#

    .SYNOPSIS
    Get Custom Properties that are set on files

    .DESCRIPTION
    Get Custom Properties that are set on files. If someone has a file open the properties cannot be read.

	.PARAMETER Path
	Path to file, typically a microsoft extension (docx, xlsx, pptx)

    .EXAMPLE
    $File = Get-item '../path-to-file'
    $File | customprops

    .EXAMPLE
    $File = Get-item '../path-to-file'
    Get-CustomProperties -Path $File
    
#>
	Param (
		[Parameter(
			Mandatory = $true,
			ValueFromPipeline=$true
		)] $Path
	)

	Try {
		If ($Path.Gettype() -ne [string]) {
			$StringPath = (gi -LiteralPath $Path -Force).FullName
		} Else {
			$StringPath = $Path
		}
	} Catch {
		throw $_
	}

	#region Test if this is a file
	Try {
		If (Test-Path -LiteralPath $StringPath -PathType Container) {
			throw "$StringPath is not a file."
		}
	} Catch {
		throw $_
	}
	#region Test if this is a file

	Write-Verbose "Get-CustomProperties -Path $StringPath"

	$ScriptPath = $PSScriptRoot
	$Response = $null
	$OpenXML = $false

	If (Test-IfFileLocked -Path $StringPath) {
		throw [System.IO.FileLoadException] "$StringPath is open by another user, locked, or inaccessible."
	}

	#region Modern approach: Use this for xmlx or docx
	[Reflection.Assembly]::LoadWithPartialName("DocumentFormat.OpenXml") | Out-null

	Try {
		If ([DocumentFormat.OpenXml.BooleanValue]) { #Check that we have OpenXml
			$OpenXML = $true
		}
	} Catch {}

	If ($OpenXML) {
		$Document = $null

		Try { #See if it is Word
			$Document = [DocumentFormat.OpenXml.Packaging.WordprocessingDocument]::Open("$StringPath", $false)
		} Catch {}

		If (!$Document) { #See if it is Excel
			Try {
				$Document = [DocumentFormat.OpenXml.Packaging.SpreadsheetDocument]::Open("$StringPath", $false)
			} Catch {}
		}

		If (!$Document) { #See if it is Powerpoint
			Try {
				$Document = [DocumentFormat.OpenXml.Packaging.PresentationDocument]::Open("$StringPath", $false)
			} Catch {}
		}

		If ($Document) { #Get properties
			Write-Verbose "Using OpenXML"

			#Build Obj
			$Response = [PSCustomObject] @{}
			$Response | Add-Member -MemberType NoteProperty -Name "HasCustomProperties" -Value $false

			#loop over properties
			$Document.CustomFilePropertiesPart.Properties | ?{![String]::IsNullOrEmpty($_.Text)} | %{
				$Response.HasCustomProperties = $true
				$Response | Add-Member -MemberType NoteProperty -Name "$($_.Name.Value)" -Value "$($_.Text)"
			}

			$Document.Close()
		}
	}
	#endregion Modern approach: Used for xmlx or docx


	#region Legacy Support

	#region ScriptCode Block For DSO, which requires 32-bit
	$code = [ScriptBlock]{
		Param (
			[String] $StringPath,
			[String] $ScriptPath
		)

		If (!$StringPath -or !$ScriptPath)
		{
			throw "Error starting job with incorrect parameters"
		}

		Try {
			Import-Module (Join-Path -Path $ScriptPath -ChildPath './DSOFile/Interop.DSOFile.dll')  | Out-Null

			$Oled = New-Object DsoFile.OleDocumentPropertiesClass
			[void] $Oled.Open($StringPath, $true)

			#Create OledObj
			$OledObj = [PSCustomObject] @{}
			$OledObj | Add-Member -MemberType NoteProperty -Name "HasCustomProperties" -Value $false

			If ($Oled.CustomProperties.Count -gt 0) {
				$Oled.CustomProperties | ?{(![String]::IsNullOrEmpty($_.Name)) -and (![String]::IsNullOrEmpty($_.Value))} | %{
					$OledObj | Add-Member -MemberType NoteProperty -Name "$($_.Name)" -Value $_.Value
				}
				$OledObj.HasCustomProperties = $true
			}
			
			#Close Oled
			[void] $Oled.Close($false)
			[void] [System.Runtime.InteropServices.Marshal]::FinalReleaseComObject($Oled)
		} Catch {
			throw $_
		}

		return $OledObj
	}
	#region ScriptCode Block For DSO, which requires 32-bit

	If (!$Response) { #Legacy Support
		Write-Verbose "Using DSOFile"
		Try {
			$Job = (Start-Job -Name $StringPath -ScriptBlock $code -ArgumentList @($StringPath, $ScriptPath) -RunAs32)
			$Response = ($Job | Wait-Job | Receive-Job)

			If ($Job.State -eq 'Failed') {
				throw ($Job.ChildJobs[0].JobStateInfo.Reason.Message)
			}
			
			Remove-Job -Job $Job
		} Catch {
			throw $_
		}
	}
	#endregion Legacy Support

	return $Response
}

New-Alias -Name customprops -Value Get-CustomProperties
Export-ModuleMember -Function Get-CustomProperties
Export-ModuleMember -Alias customprops